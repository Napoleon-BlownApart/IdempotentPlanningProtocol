/**                                                                     
 *  /file guwhiteboardtypelist_c_generated.h                            
 *                                                                      
 *  Created by Carl Lusty in 2013.                                      
 *  Copyright (c) 2013 Carl Lusty                                       
 *  All rights reserved.                                                
 */                                                                     


#ifndef _GUWHITEBOARD_TYPELIST_C_H_                                     
#define _GUWHITEBOARD_TYPELIST_C_H_                                     


#define WANT_WB_STRINGS

#define GSW_NUM_TYPES_DEFINED 45

#if GSW_NUM_TYPES_DEFINED > GSW_NUM_RESERVED
#error *** Error: gusimplewhiteboard: The number of defined types exceeds the total number of reserved types allowed. Increase GSW_NUM_RESERVED to solve this.
#endif
//Generated on: Wed Jan 20 00:03:35 2016
//Generated by user: nap

       /** All the message 'types' for the class based whiteboard */
       typedef enum wb_types      
        {                                                               
                kwb_reserved_SubscribeToAllTypes_v = 0,	///< Global subscription type. Do not add content to this type, it is for global subscriptions only
                kPrint_v = 1,	///< print to stdout
                kSay_v = 2,	///< speech output message
                kSpeech_v = 3,	///< debug speech message
                kQSay_v = 4,	///< speech output message (queued)
                kQSpeech_v = 5,	///< debug speech message (queued)
                kSpeechOutput_v = 6,	///< toggle, treat speech messages as silent output unless this is turned on
                kFSM_Control_v = 7,	///< Suspend, Resume, or Restart a finite state machine (clfsm)
                kFSM_Status_v = 8,	///< Current status indicating the suspended state of all FSMs.  The highest bit that is always set is the number of machines plus one.
                kFSM_Names_v = 9,	///< Request or return the names of the currently loaded FSMs.  End of list is denoted by an empty string.  Requests need to put an empty string into the first FSM name;
                kFSM_States_v = 10,	///< Idempotent Message publicising the state -about to be executed- (0-254) of up-to the first 128 machines (0-127).  State -INVALDMACHINE- (255) is posted for MachineIDs that are not currently loaded.
                kSENSORS_EPuckAccel_Control_v = 11,	///< Controls which accelerometer sensors are on/off
                kSENSORS_EPuckAccel_Status_v = 12,	///< Reports status of accelerometers (on/off & value)
                kSENSORS_EPuckCamera_Control_v = 13,	///< Controls Camera Settings
                kSENSORS_EPuckCamera_Status_v = 14,	///< Reports Camera data
                kSENSORS_EPuckGSM_Control_v = 15,	///< Controls which accelerometer sensors are on/off
                kSENSORS_EPuckGSM_Status_v = 16,	///< Reports status of accelerometers (on/off & value)
                kSENSORS_EPuckLight_Control_v = 17,	///< Controls which accelerometer sensors are on/off
                kSENSORS_EPuckLight_Status_v = 18,	///< Reports status of accelerometers (on/off & value)
                kSENSORS_EPuckProximity_Control_v = 19,	///< Controls which accelerometer sensors are on/off
                kSENSORS_EPuckProximity_Status_v = 20,	///< Reports status of accelerometers (on/off & value)
                kDifferentialRobotControl_v = 21,	///< Controls Differential Motors
                kDifferentialRobotStatus_v = 22,	///< Reports status of Differential Motors
                kEMITTERS_EPuckLED_Control_v = 23,	///< Controls which LED Emitters are on/off and what intensity
                kEMITTERS_EPuckLED_Status_v = 24,	///< Reports status of LED Emitters (on/off & intensity)
                kGOAL_Control_v = 25,	///< GOAL Control Message
                kGOAL_Status_v = 26,	///< GOAL Status Message
                kSENSORS_Intersection_Status_v = 27,	///< Intersection Status Message
                kDirection_Control_v = 28,	///< Direction Control (which way to go F/L/R/AR/AL)
                kSENSORS_Obstacle_On_Path_v = 29,	///< Obstacle On Path (true between detecting it and returning to intersection)
                kAngle_v = 30,	///< Angle of the epuck (0 = North)
                kSENSORS_Obstacle_v = 31,	///< Obstacle (true only while the obstacle is there)
                kCurrent_Position_v = 32,	///< Current Position
                kPlan_Planner_Settings_v = 33,	///< Planner Settings
                kPlan_Domain_Filename_v = 34,	///< Filename of the PDDL Domain the Planner will try to solve
                kPlan_Problem_Filename_v = 35,	///< Filename of the PDDL Problem the Planner will try to solve
                kPlan_Obstacles_Filename_v = 36,	///< Filename of the Obstacle List
                kPlan_Plan_Filename_v = 37,	///< Filename of the Plan
                kPlan_Manager_Status_v = 38,	///< Plan Manager Status
                kPlan_Planner_Status_v = 39,	///< Planner Status
                kPlan_Goal_List_v = 40,	///< List of sub-goals (works like FSMNames)
                kPlan_Obstacle_List_v = 41,	///< List of obstacles (works like FSMNames)
                kEpuck_Test_Control_v = 42,	///< Epuck Test Control Message
                kEpuck_Test_Status_v = 43,	///< Epuck Test Status Message
                kEpuck_Test_Start_Up_v = 44	///< Epuck Test Start Up State Message
        } WBTypes; ///< All the message 'types' for the class based whiteboard 

        extern const char *WBTypes_stringValues[];
#endif                          
