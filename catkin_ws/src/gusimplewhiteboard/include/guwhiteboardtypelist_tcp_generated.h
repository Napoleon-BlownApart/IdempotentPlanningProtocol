/**                                                                    
*  /file guwhiteboardtypelist_tcp_generated.h                          
*                                                                      
*  Created by Carl Lusty in 2013.                                      
*  Copyright (c) 2013 Carl Lusty                                       
*  All rights reserved.                                                
*/                                                                     


#ifndef _GUWHITEBOARD_TCP_TYPELIST_H_                                  
#define _GUWHITEBOARD_TCP_TYPELIST_H_                                  

#include "gugenericwhiteboardobject.h"                                
#include "gutcpinjectionwhiteboardobject.h"                           

#pragma clang diagnostic push                                           
#pragma clang diagnostic ignored "-Wpadded"                           
#pragma clang diagnostic ignored "-Wold-style-cast"                   


//Generated on: Wed Jan 20 00:03:35 2016
//Generated by user: nap

namespace guWhiteboard                                                  
{                                                                       
                                                                        
extern "C"                                                            
{                                                                       
#include "guwhiteboardtypelist_c_generated.h"                         
}                                                                       
                                                                        
	/** WB Ptr Class: Print @brief print to stdout */ 
        class Print_iTCP: public injection_whiteboard_object<std::string > { 
	public: 
		/** Constructor: Print */ 
		Print_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(hostname, kPrint_v, is_async) {}
		/** Constructor: Print */ 
		Print_iTCP(std::string value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(value, hostname, kPrint_v, is_async) {} 
	};

	/** WB Ptr Class: Say @brief speech output message */ 
        class Say_iTCP: public injection_whiteboard_object<std::string > { 
	public: 
		/** Constructor: Say */ 
		Say_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(hostname, kSay_v, is_async) {}
		/** Constructor: Say */ 
		Say_iTCP(std::string value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(value, hostname, kSay_v, is_async) {} 
	};

	/** WB Ptr Class: Speech @brief debug speech message */ 
        class Speech_iTCP: public injection_whiteboard_object<std::string > { 
	public: 
		/** Constructor: Speech */ 
		Speech_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(hostname, kSpeech_v, is_async) {}
		/** Constructor: Speech */ 
		Speech_iTCP(std::string value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(value, hostname, kSpeech_v, is_async) {} 
	};

	/** WB Ptr Class: QSay @brief speech output message (queued) */ 
        class QSay_iTCP: public injection_whiteboard_object<std::string > { 
	public: 
		/** Constructor: QSay */ 
		QSay_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(hostname, kQSay_v, is_async) {}
		/** Constructor: QSay */ 
		QSay_iTCP(std::string value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(value, hostname, kQSay_v, is_async) {} 
	};

	/** WB Ptr Class: QSpeech @brief debug speech message (queued) */ 
        class QSpeech_iTCP: public injection_whiteboard_object<std::string > { 
	public: 
		/** Constructor: QSpeech */ 
		QSpeech_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(hostname, kQSpeech_v, is_async) {}
		/** Constructor: QSpeech */ 
		QSpeech_iTCP(std::string value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<std::string >(value, hostname, kQSpeech_v, is_async) {} 
	};

	/** WB Ptr Class: SpeechOutput @brief toggle, treat speech messages as silent output unless this is turned on */ 
        class SpeechOutput_iTCP: public injection_whiteboard_object<bool > { 
	public: 
		/** Constructor: SpeechOutput */ 
		SpeechOutput_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(hostname, kSpeechOutput_v, is_async) {}
		/** Constructor: SpeechOutput */ 
		SpeechOutput_iTCP(bool value, const char *hostname = (const char *)"localhost", bool is_async = true): injection_whiteboard_object<bool >(value, hostname, kSpeechOutput_v, is_async) {} 
	};

	/** WB Ptr Class: FSM_Control @brief Suspend, Resume, or Restart a finite state machine (clfsm) */ 

        class FSM_Control_iTCP: public injection_whiteboard_object<class FSMControlStatus > { 
	public: 
		/** Constructor: FSM_Control */ 
		FSM_Control_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class FSMControlStatus >(hostname, kFSM_Control_v, is_async) {} 
	};

	/** WB Ptr Class: FSM_Status @brief Current status indicating the suspended state of all FSMs.  The highest bit that is always set is the number of machines plus one. */ 

        class FSM_Status_iTCP: public injection_whiteboard_object<class FSMControlStatus > { 
	public: 
		/** Constructor: FSM_Status */ 
		FSM_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class FSMControlStatus >(hostname, kFSM_Status_v, is_async) {} 
	};

	/** WB Ptr Class: FSM_Names @brief Request or return the names of the currently loaded FSMs.  End of list is denoted by an empty string.  Requests need to put an empty string into the first FSM name; */ 

        class FSM_Names_iTCP: public injection_whiteboard_object<class FSMNames > { 
	public: 
		/** Constructor: FSM_Names */ 
		FSM_Names_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class FSMNames >(hostname, kFSM_Names_v, is_async) {} 
	};

	/** WB Ptr Class: FSM_States @brief Idempotent Message publicising the state -about to be executed- (0-254) of up-to the first 128 machines (0-127).  State -INVALDMACHINE- (255) is posted for MachineIDs that are not currently loaded. */ 

        class FSM_States_iTCP: public injection_whiteboard_object<class FSMState > { 
	public: 
		/** Constructor: FSM_States */ 
		FSM_States_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class FSMState >(hostname, kFSM_States_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORS_EPuckAccel_Control @brief Controls which accelerometer sensors are on/off */ 

        class SENSORS_EPuckAccel_Control_iTCP: public injection_whiteboard_object<class SENSORS_EPuckAccel_Control > { 
	public: 
		/** Constructor: SENSORS_EPuckAccel_Control */ 
		SENSORS_EPuckAccel_Control_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORS_EPuckAccel_Control >(hostname, kSENSORS_EPuckAccel_Control_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORS_EPuckAccel_Status @brief Reports status of accelerometers (on/off & value) */ 

        class SENSORS_EPuckAccel_Status_iTCP: public injection_whiteboard_object<class SENSORS_EPuckAccel_Status > { 
	public: 
		/** Constructor: SENSORS_EPuckAccel_Status */ 
		SENSORS_EPuckAccel_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORS_EPuckAccel_Status >(hostname, kSENSORS_EPuckAccel_Status_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORS_EPuckCamera_Control @brief Controls Camera Settings */ 

        class SENSORS_EPuckCamera_Control_iTCP: public injection_whiteboard_object<class SENSORS_EPuckCamera_ControlStatus > { 
	public: 
		/** Constructor: SENSORS_EPuckCamera_Control */ 
		SENSORS_EPuckCamera_Control_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORS_EPuckCamera_ControlStatus >(hostname, kSENSORS_EPuckCamera_Control_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORS_EPuckCamera_Status @brief Reports Camera data */ 

        class SENSORS_EPuckCamera_Status_iTCP: public injection_whiteboard_object<class SENSORS_EPuckCamera_ControlStatus > { 
	public: 
		/** Constructor: SENSORS_EPuckCamera_Status */ 
		SENSORS_EPuckCamera_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORS_EPuckCamera_ControlStatus >(hostname, kSENSORS_EPuckCamera_Status_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORS_EPuckGSM_Control @brief Controls which accelerometer sensors are on/off */ 

        class SENSORS_EPuckGSM_Control_iTCP: public injection_whiteboard_object<class SENSORS_EPuckGSM_Control > { 
	public: 
		/** Constructor: SENSORS_EPuckGSM_Control */ 
		SENSORS_EPuckGSM_Control_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORS_EPuckGSM_Control >(hostname, kSENSORS_EPuckGSM_Control_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORS_EPuckGSM_Status @brief Reports status of accelerometers (on/off & value) */ 

        class SENSORS_EPuckGSM_Status_iTCP: public injection_whiteboard_object<class SENSORS_EPuckGSM_Status > { 
	public: 
		/** Constructor: SENSORS_EPuckGSM_Status */ 
		SENSORS_EPuckGSM_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORS_EPuckGSM_Status >(hostname, kSENSORS_EPuckGSM_Status_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORS_EPuckLight_Control @brief Controls which accelerometer sensors are on/off */ 

        class SENSORS_EPuckLight_Control_iTCP: public injection_whiteboard_object<class SENSORS_EPuckLight_Control > { 
	public: 
		/** Constructor: SENSORS_EPuckLight_Control */ 
		SENSORS_EPuckLight_Control_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORS_EPuckLight_Control >(hostname, kSENSORS_EPuckLight_Control_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORS_EPuckLight_Status @brief Reports status of accelerometers (on/off & value) */ 

        class SENSORS_EPuckLight_Status_iTCP: public injection_whiteboard_object<class SENSORS_EPuckLight_Status > { 
	public: 
		/** Constructor: SENSORS_EPuckLight_Status */ 
		SENSORS_EPuckLight_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORS_EPuckLight_Status >(hostname, kSENSORS_EPuckLight_Status_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORS_EPuckProximity_Control @brief Controls which accelerometer sensors are on/off */ 

        class SENSORS_EPuckProximity_Control_iTCP: public injection_whiteboard_object<class SENSORS_EPuckProximity_Control > { 
	public: 
		/** Constructor: SENSORS_EPuckProximity_Control */ 
		SENSORS_EPuckProximity_Control_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORS_EPuckProximity_Control >(hostname, kSENSORS_EPuckProximity_Control_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORS_EPuckProximity_Status @brief Reports status of accelerometers (on/off & value) */ 

        class SENSORS_EPuckProximity_Status_iTCP: public injection_whiteboard_object<class SENSORS_EPuckProximity_Status > { 
	public: 
		/** Constructor: SENSORS_EPuckProximity_Status */ 
		SENSORS_EPuckProximity_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORS_EPuckProximity_Status >(hostname, kSENSORS_EPuckProximity_Status_v, is_async) {} 
	};

	/** WB Ptr Class: DifferentialRobotControl @brief Controls Differential Motors */ 

        class DifferentialRobotControl_iTCP: public injection_whiteboard_object<class DifferentialRobotControlStatus > { 
	public: 
		/** Constructor: DifferentialRobotControl */ 
		DifferentialRobotControl_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class DifferentialRobotControlStatus >(hostname, kDifferentialRobotControl_v, is_async) {} 
	};

	/** WB Ptr Class: DifferentialRobotStatus @brief Reports status of Differential Motors */ 

        class DifferentialRobotStatus_iTCP: public injection_whiteboard_object<class DifferentialRobotControlStatus > { 
	public: 
		/** Constructor: DifferentialRobotStatus */ 
		DifferentialRobotStatus_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class DifferentialRobotControlStatus >(hostname, kDifferentialRobotStatus_v, is_async) {} 
	};

	/** WB Ptr Class: EMITTERS_EPuckLED_Control @brief Controls which LED Emitters are on/off and what intensity */ 

        class EMITTERS_EPuckLED_Control_iTCP: public injection_whiteboard_object<class EMITTERS_EPuckLED_ControlStatus > { 
	public: 
		/** Constructor: EMITTERS_EPuckLED_Control */ 
		EMITTERS_EPuckLED_Control_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class EMITTERS_EPuckLED_ControlStatus >(hostname, kEMITTERS_EPuckLED_Control_v, is_async) {} 
	};

	/** WB Ptr Class: EMITTERS_EPuckLED_Status @brief Reports status of LED Emitters (on/off & intensity) */ 

        class EMITTERS_EPuckLED_Status_iTCP: public injection_whiteboard_object<class EMITTERS_EPuckLED_ControlStatus > { 
	public: 
		/** Constructor: EMITTERS_EPuckLED_Status */ 
		EMITTERS_EPuckLED_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class EMITTERS_EPuckLED_ControlStatus >(hostname, kEMITTERS_EPuckLED_Status_v, is_async) {} 
	};

	/** WB Ptr Class: GOAL_Control @brief GOAL Control Message */ 

        class GOAL_Control_iTCP: public injection_whiteboard_object<class GOAL_Control > { 
	public: 
		/** Constructor: GOAL_Control */ 
		GOAL_Control_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class GOAL_Control >(hostname, kGOAL_Control_v, is_async) {} 
	};

	/** WB Ptr Class: GOAL_Status @brief GOAL Status Message */ 

        class GOAL_Status_iTCP: public injection_whiteboard_object<class GOAL_Status > { 
	public: 
		/** Constructor: GOAL_Status */ 
		GOAL_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class GOAL_Status >(hostname, kGOAL_Status_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORS_Intersection_Status @brief Intersection Status Message */ 

        class SENSORS_Intersection_Status_iTCP: public injection_whiteboard_object<class SENSORS_Intersection_Status > { 
	public: 
		/** Constructor: SENSORS_Intersection_Status */ 
		SENSORS_Intersection_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORS_Intersection_Status >(hostname, kSENSORS_Intersection_Status_v, is_async) {} 
	};

	/** WB Ptr Class: Direction_Control @brief Direction Control (which way to go F/L/R/AR/AL) */ 

        class Direction_Control_iTCP: public injection_whiteboard_object<class Direction_Control > { 
	public: 
		/** Constructor: Direction_Control */ 
		Direction_Control_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Direction_Control >(hostname, kDirection_Control_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORS_Obstacle_On_Path @brief Obstacle On Path (true between detecting it and returning to intersection) */ 

        class SENSORS_Obstacle_On_Path_iTCP: public injection_whiteboard_object<class SENSORS_Obstacle_On_Path > { 
	public: 
		/** Constructor: SENSORS_Obstacle_On_Path */ 
		SENSORS_Obstacle_On_Path_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORS_Obstacle_On_Path >(hostname, kSENSORS_Obstacle_On_Path_v, is_async) {} 
	};

	/** WB Ptr Class: Angle @brief Angle of the epuck (0 = North) */ 

        class Angle_iTCP: public injection_whiteboard_object<class Angle > { 
	public: 
		/** Constructor: Angle */ 
		Angle_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Angle >(hostname, kAngle_v, is_async) {} 
	};

	/** WB Ptr Class: SENSORS_Obstacle @brief Obstacle (true only while the obstacle is there) */ 

        class SENSORS_Obstacle_iTCP: public injection_whiteboard_object<class SENSORS_Obstacle > { 
	public: 
		/** Constructor: SENSORS_Obstacle */ 
		SENSORS_Obstacle_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class SENSORS_Obstacle >(hostname, kSENSORS_Obstacle_v, is_async) {} 
	};

	/** WB Ptr Class: Current_Position @brief Current Position */ 

        class Current_Position_iTCP: public injection_whiteboard_object<class Current_Position > { 
	public: 
		/** Constructor: Current_Position */ 
		Current_Position_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Current_Position >(hostname, kCurrent_Position_v, is_async) {} 
	};

	/** WB Ptr Class: Plan_Planner_Settings @brief Planner Settings */ 

        class Plan_Planner_Settings_iTCP: public injection_whiteboard_object<class Plan_Planner_Settings > { 
	public: 
		/** Constructor: Plan_Planner_Settings */ 
		Plan_Planner_Settings_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Plan_Planner_Settings >(hostname, kPlan_Planner_Settings_v, is_async) {} 
	};

	/** WB Ptr Class: Plan_Domain_Filename @brief Filename of the PDDL Domain the Planner will try to solve */ 

        class Plan_Domain_Filename_iTCP: public injection_whiteboard_object<class Plan_Filename > { 
	public: 
		/** Constructor: Plan_Domain_Filename */ 
		Plan_Domain_Filename_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Plan_Filename >(hostname, kPlan_Domain_Filename_v, is_async) {} 
	};

	/** WB Ptr Class: Plan_Problem_Filename @brief Filename of the PDDL Problem the Planner will try to solve */ 

        class Plan_Problem_Filename_iTCP: public injection_whiteboard_object<class Plan_Filename > { 
	public: 
		/** Constructor: Plan_Problem_Filename */ 
		Plan_Problem_Filename_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Plan_Filename >(hostname, kPlan_Problem_Filename_v, is_async) {} 
	};

	/** WB Ptr Class: Plan_Obstacles_Filename @brief Filename of the Obstacle List */ 

        class Plan_Obstacles_Filename_iTCP: public injection_whiteboard_object<class Plan_Filename > { 
	public: 
		/** Constructor: Plan_Obstacles_Filename */ 
		Plan_Obstacles_Filename_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Plan_Filename >(hostname, kPlan_Obstacles_Filename_v, is_async) {} 
	};

	/** WB Ptr Class: Plan_Plan_Filename @brief Filename of the Plan */ 

        class Plan_Plan_Filename_iTCP: public injection_whiteboard_object<class Plan_Filename > { 
	public: 
		/** Constructor: Plan_Plan_Filename */ 
		Plan_Plan_Filename_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Plan_Filename >(hostname, kPlan_Plan_Filename_v, is_async) {} 
	};

	/** WB Ptr Class: Plan_Manager_Status @brief Plan Manager Status */ 

        class Plan_Manager_Status_iTCP: public injection_whiteboard_object<class Plan_Control_Status > { 
	public: 
		/** Constructor: Plan_Manager_Status */ 
		Plan_Manager_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Plan_Control_Status >(hostname, kPlan_Manager_Status_v, is_async) {} 
	};

	/** WB Ptr Class: Plan_Planner_Status @brief Planner Status */ 

        class Plan_Planner_Status_iTCP: public injection_whiteboard_object<class Plan_Control_Status > { 
	public: 
		/** Constructor: Plan_Planner_Status */ 
		Plan_Planner_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Plan_Control_Status >(hostname, kPlan_Planner_Status_v, is_async) {} 
	};

	/** WB Ptr Class: Plan_Goal_List @brief List of sub-goals (works like FSMNames) */ 

        class Plan_Goal_List_iTCP: public injection_whiteboard_object<class Plan_Goal_List > { 
	public: 
		/** Constructor: Plan_Goal_List */ 
		Plan_Goal_List_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Plan_Goal_List >(hostname, kPlan_Goal_List_v, is_async) {} 
	};

	/** WB Ptr Class: Plan_Obstacle_List @brief List of obstacles (works like FSMNames) */ 

        class Plan_Obstacle_List_iTCP: public injection_whiteboard_object<class Plan_Obstacle_List > { 
	public: 
		/** Constructor: Plan_Obstacle_List */ 
		Plan_Obstacle_List_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Plan_Obstacle_List >(hostname, kPlan_Obstacle_List_v, is_async) {} 
	};

	/** WB Ptr Class: Epuck_Test_Control @brief Epuck Test Control Message */ 

        class Epuck_Test_Control_iTCP: public injection_whiteboard_object<class Epuck_Test > { 
	public: 
		/** Constructor: Epuck_Test_Control */ 
		Epuck_Test_Control_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Epuck_Test >(hostname, kEpuck_Test_Control_v, is_async) {} 
	};

	/** WB Ptr Class: Epuck_Test_Status @brief Epuck Test Status Message */ 

        class Epuck_Test_Status_iTCP: public injection_whiteboard_object<class Epuck_Test > { 
	public: 
		/** Constructor: Epuck_Test_Status */ 
		Epuck_Test_Status_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Epuck_Test >(hostname, kEpuck_Test_Status_v, is_async) {} 
	};

	/** WB Ptr Class: Epuck_Test_Start_Up @brief Epuck Test Start Up State Message */ 

        class Epuck_Test_Start_Up_iTCP: public injection_whiteboard_object<class Epuck_Test > { 
	public: 
		/** Constructor: Epuck_Test_Start_Up */ 
		Epuck_Test_Start_Up_iTCP(const char *hostname = (const char *)"localhost", bool is_async = true) : injection_whiteboard_object<class Epuck_Test >(hostname, kEpuck_Test_Start_Up_v, is_async) {} 
	};

}

#pragma clang diagnostic pop

#endif                          
